dj: The Django CLI
==================

`dj` is a command-line tool that automates the repetitive workflows necessary
to manage Django application code:

* Setting up a new project
* Managing project dependencies
* Building and running the project
* Generating new code stubs

# Why `dj`?

While there are existing tools that address some of these workflows at the language and framework level
(django-admin, cookiecutter, virtualenv, make),
each tool has its own learning curve, and there are few integration points between them.

The reality of this ecosystem is often an uncertain and boilerplate developer experience, especially
for newcomers. 

`dj`, insipred by ember-cli, attempts to fill these gaps by providing a simple, comprehensive, and extendable
interface for the Django development lifecycle. `dj` is built in Python and provides familiar integration
points for Python developers.

# Getting Started

## Installation

To install `dj`, simply run [the appropriate installer](./INSTALLERS.md) for your operating system.
`dj` distributes with PyInstaller and runs within an isolated Python environment.

## Commands

Run `dj --help` to see a list of supported commands.
Run `dj SUBCOMMAND --help` for help on any specific subcommand:

### dj info

Display information about the current app.

### dj init NAME [--runtime=2.7.9]

Sets up a shell Django project in the current directory.
This command will prompt for all optional arguments, unless passed in.

### dj add ADDON

Add a dependency to the project. The dependency must be given in pip depdendency notation.

If `--dev` is passed, the addon will only be required for testing and local development.
Otherwise, the addon will be installed in production.

If the `addon` has an `init` blueprint, the `init` blueprint will be generated.

For example:

    dj add dynamic-rest==1.5.0
    dj add dynamic-rest
    dj add git+https://github.com/AltSchool/dynamic-rest@master#egg=dynamic-rest

### dj remove ADDON

Removes an installed addon, the inverse of `dj add`.

### dj generate [ADDON.]BLUEPRINT [...ARGS]

Generates a set of modules given a blueprint. The blueprint can be prefixed by the name
of an addon and may take several arguments.

The following core blueprints are supported:

1. init NAME
    Project blueprint, creates the project/application from scratch.
2. model NAME
    Create a model and associated test.
3. command NAME
    Create a command and associated test.

### dj run COMMAND [...ARGS]

Run any Django command in development mode.

The app is built and run in a virtual environment.
The runtime specified during initialization is used.

### dj lint FILTER --fix

Lints code files using `flake8` / fixes with `autopep8`.

### dj test FILTER --runner

Run tests within the project.
This uses `manage.py test` or provided runner (e.g. `py.test`) to run all test cases in the `tests` package.

# Developing apps

It is easy to turn an existing Python or Django library into a `dj`-compatible app that be used standalone or
as an addon to another app. The term "addon" is used to mean that the application code can be used as a library
and that its blueprints can be generated.

## Guiding principles

Django apps using `dj` should follow these principles.
Most are recommended, some are required.

1. Consistency

    Apps should follow a predictable file and metadata structure.

a. An app MUST have a name.

    This name should contain only lower-case letters and underscores.

b. An app MUST have only one top-level code package sharing the app's name.

    The package name should be the same as the app name.

    For example:
        
        app "foo" would package all of its code under the "foo" package.

c. An app MUST have a top-level `setup.py` file.
    
    The setup.py file is used by Python installer tools (pip, setuptools, easy_install)
    to determine your package's core dependencies and basic information.

    This setup.py file should include a `name` for your app, which should match the name of your primary
    app package.

    This file is generated by `dj init` and is required by most `dj` commands.

d. An app may have a top-level `manage.py` script.

    This manage.py script should be included in the `scripts` directive in `setup.py`.
    `dj init` will set this up for you. Addons do not necessarily need this.

    Django-specific commands like `migrate`, `shell`, and `serve` will not work without this script.
    However, generic Python commands `generate`, `test`, and `run` can still be used.

    This file is generated automatically by `dj init`.

e. An app may include a top-level `requirements.txt` dependency file.
    
    The most common way for apps to install their dependencies is using a pip-formatted requirements file.
    When pip installs from a requirements file, it first downloads each required package. It then installs
    each package with `python setup.py install`, which can download and install further packages as defined
    in the`install_requires` setup directive.
    
    The caveat to `requirements.txt` is that pip does not run itself recursively on this file, so library apps
    that want to distribute with other dependencies need to add the `setup.py` directives: `install_requires` and 
    `dependency_links`. `dj` works around this by using a special loader in `setup.py` that reduces `requirements.txt`
    to `install_requires` and `dependency_links`. This allows you to keep your core dependencies in one place and provide
    support for botbh `pip` and `setuptools` installations.

    This file is generated automatically by `dj init` and updated by `dj add` and `dj remove`.

f. An app may have a top-level `requirements.txt.dev` dependency file.

    This file is used to install development packages that would not be installed in production.

    This file is generated automatically by `dj init` and updated by `dj add --dev` and `dj remove --dev`.

g. The code package of the app should contain settings.py, wsgi.py, and urls.py packages.
    
    These packages are necessary for Django applications to load. A models.py file is recommended.
    
    settings.py:
        Django configuration file, used to define all core and accessory settings.
        
        Try to use a single configuration file between different environments, with environment secrets
        to differentiate instead.
    
    wsgi.py:
        Exports the WSGI server entrypoint, loaded by a WSGI server to access the Django application.

        Configurable by the WSGI_APPLICATION setting (defaults to $APP.wsgi.application)

    urls.py:
        The URL routing file, should export `urlpatterns`, a list of route matching patterns.

    These files are generated automatically by `dj init`.

h. An app should be written in a single code style.

    Style should be enforced by a linter (e.g. `flake8`).
    Naming should be kept consistent between different modules.

i. An app should contain a tests package for all unit and integration tests.
    
    The package `foo.models.bar` should be tested by `tests.unit.foo.models.test_bar`.

2. Minimalism

    Apps should aim to reduce code and complexity wherever possible.

a. An app should only export one package.
    
    When dependencies are installed in the pip/setuptools model,
    the top-level packages of a dependency are added to the application's environment.

    The free mapping between dependency and packages can be confusing, as dependencies and packages can be
    spelled slightly differently (e.g. my-dep and my_dep), and dependencies can provide conflicting packages (e.g. my-dep providing foo and other-dep also providing foo).
    
    To mitigate this issue, apps should provide a single package that has the same name as the application name.

b. App code should be concise. 

    Re-use shared utility code.
    Avoid self-repetition in code (DRY).

    Use structure to manage frequently growing lists of code components, e.g. models.

    For example:
    
        Don't store all of your models in models.py.
        This file will grow to the point where it becomes unweildy.

        Instead, create one file per model, with the complete list
        defined in models/__init__.py for compatability with the Django model loader.

c. App structure should be concise.

    Re-use structural patterns.
    Avoid creating unnecessary structure.

    Create components within your code package.
    Components should have a name (the class name), and we can derive a type (the last functional component),
    and a prefix (all functional components leading up to the type component).

    Use a hierarchical structure to group components together,
    either functionally or logically.

    For example:
        
        Add models into the `$APP.models` package.
        A model's type is "model", path is "$APP.models", and name is "Foo".

        Add API serializers into the `$APP.api.$VERSION.serializers` package.
        A serializer's type is "serializer", prefix is "$APP.api.v0.serializers", and name is "Foo".

        Add API views into the `$APP.api.$VERSION.views` package.
        A view's type is "view", prefix is "$APP.api.v0", and name is "User".

## Blueprints

Blueprints allows addons to establish structural conventions for
their implementions through the code generation features built into `dj`.

A blueprint is a Python package with a `context.py` module that describes the input to the generator function
and a `templates` folder that describes the output.

### context.py

A blueprint's `context` package should export a single method called `get_context` that serves as a `click`
entrypoint for the blueprint. This entrypoint should describe the required and optional parameters using
`click` decorators and should return the context that will be called by `dj`'s generation methods.

Example:

```
import click

@click.command()
@click.argument('name')
@click.option('--class-name')
def get_context(name, class_name):
    return {
        'name': name,
        'class_name': class_name or name.title()
    }
```

### templates

A blueprint's templates folder contains `Jinja` template files that are rendered and merged into an existing
application when the blueprint is called. All Jinja files should be suffixed with `.j2`.

#### rendering

Blueprints are rendered by applying the context passed to `dj`s `generate` method to each of the files
in the `templates` directory. In addition, file names containing double-underscore delimited variables are replaced by values
from the context. The "app" variable is automatically populated by `dj` with the name of the current application.

For example, the model blueprint:
```
/
    {{app}}/
        models/
            __init__.py
                # cli: merge
                from .{{ name }} import {{ class_name }}
            __name__.py
                from django.db import models
                class {{ class_name }}(models.Model):
                    pass
```

Might be rendered as follows for app "foo" and name "bar":

```
/
    foo/
        models/
            __init__.py
                # cli: merge
                from .bar import Bar
            bar.py
                from django.db import models
                class Bar(models.Model):
                    pass
```

#### merging

After a blueprint has been rendered, it is merged into the current application folder by folder.
The following rules are used for each folder:

* Folders and files in the blueprint that do not already exist within an application are created
* Files within the blueprint that do exist and match exactly are ignored
* For files within the blueprint that do not match:
  * If the blueprint file does not contain the `cli: merge` directive, the user will be prompted to replace the file during generation
  * If the blueprint does contain the `cli: merge` directive, the two files will be merged together statement by statement:
    * Import statements that match exactly are only rendered once
    * Assignment statements that match exactly are only rendered once
    * Assignment statements to the same variable with different list/set/dict-type values have their values merged

For example, suppose that app "foo" has the following structure:

```
/
    ...
    foo/
        settings.py
            ...
        models/
            __init__.py
                from .qux import Qux
            qux.py
                ...
```

After merging in the blueprint for model "bar" from the above example, the structure would look like:

```
/
    ...
    foo/
        settings.py
            ...
        models/
            __init__.py
                from .qux import Qux
                from .bar import Bar
            bar.py
                from django.db import models
                class Bar(models.Model):
                    pass
            qux.py
                ...
```

# Implementation Details

`dj` is written in Python and depends on the following libraries.

## Code merging

`dj` uses `redbaron` to merge Python files (FST-merge).

## CLI Parsing

`dj` uses `click` to handle CLI input. 

## Rendering

`dj` uses `Jinja2` to render templates.

## Virtual environment

`dj` uses `virtualenv` to build the app in an isolated environment.

## Python runtime

`dj` uses `pyenv` to manage multiple runtimes / versions of Python. `pyenv` will be installed if not already present.
